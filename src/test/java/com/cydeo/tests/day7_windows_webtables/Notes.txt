- DropDown

- How many dropdowns we have?
 - We have 2 type of dropdowns: - HTML dropdown
                                - Select dropdown

- How do you handle dropdowns?
 - First we will inspect and see what type of dropdown it is
 - If it is HTML dropdown (non-select), we will just locate with any locator and click on it
 - If it is Select dropdown(has <select> tag), we will use Select class to handle it. Select class is coming from Selenium library

- How do we get all of the options from Select dropdown?
 -.getOptions()

- What is the return type?
 - List<WebElement>

- How do we get currently selected option?
 - .getFirstSelectedOption()
 - This method can be used to get the default option
 - Also can be used to get the option after select something

- What is the return type?
 - Single WebElement

- How do we select options from Select dropdown?
 - We can use 3 methods provided by Selenium Library
  - selectByVisibleText
  - selectByValue
  - selectByIndex

- Syntax of how do we handle Select dropdown?
 - We create object of Select class
 - We need to locate the dropdown <select> tag itself and pass it into Select constructor

  Select dropdownName = new Select(driver.findElement(By.LocatorOfSelectTag));

 - We can use the object for handling the dropdown

  dropdownName.selectByVisibleText();


---------------------------------------------------------

- ALERT:

- What is an Alert?
 - Some pop-ups happening on the page
 - Developers use alerts to get users attention to deliver some content

- How many types of alerts we have?
 - We have 2 types of Alerts

#1. HTML Alert(NON-JS Alert)
 - This will be present inside of the <html> page as regular webElement.
 - There is nothing special about this alert, we just locate and click

#2. JAVASCRIPT Alert
 - We have 3 types of JS Alert

  #1. Information/Warning Alert:
    - User can only accept this alert

  #2. Confirmation Alert:
    -  User can accept or decline

  #3. Prompt Alert:
    - User can accept,decline, and also sendKeys

- How do we handle Alerts using Selenium?
 - I will check the type of the alert.
 - After making sure  it is a JS- Alert, we will use Alert interface from Selenium library to switch driver to focus on Alert itself

 Alert alert = driver.switchTo().alert();

 alert.accept();
 alert.dismiss();
 alert.sendKeys();
 alert.getText();


 ----------------------------------------------------------

 - IFRAME:

  - What is an Iframe?
   - It is a HTML page inside another HTML page
   - Most of the time  it is used to create independent sections in a page for ads, maps, video content or anything related to webPage

 - How do we handle iframes?
  - Selenium web driver can focus only one thing at a time.
  - Therefore we must switch its focus from default <html> to iframe <html> before being able to do any action inside of it.

 - What happens if we do not switvh to inner iframe?
  - If we try  to locate any webelement before switching, we will get NoSuchElementException

 - HOw many ways we have to switch to inner iframe?

  #1. by index:
    - starts from 0
    - we will count it

    driver.switchTo().frame(int index)

  #2. by id/name value
    - If there is id or name attribute we can just pass their value

    driver.switchTo().frame("id-name value")

 #3. by locating it as web element
   - we just locate iframe tag itself as a webElement and pass into frame method

   driver.switchTo().frame(driver.findElement(By.locator))


 - How do we go switch drivers's focus to default html from iframe?
  - driver.switchTo().parentFrame() --> if there is nested iframe it will go parent frame
  - driver.switchTo().defaultContent() --> This will take us main HTML


1 <html> --> Main HTML


2  <html>  --> parentFrame

3    <html> --> driver.switchTo().parentFrame(); --> focus on line #2

    </html> --> driver.switchTo().defaultContent() --> focus on line #1

 </html>


--------------------------------------------------------

- WINDOWS:

- is there any difference for selenium if it is a tab or window?
 - No. Regardless if it is a window or a tab it is all a WINDOW for Selenium

- How does Selenium knows which window is different from which?
 - windowHandles

- What is a window handle?
 - A randomly generated unique alphanumeric ID for each window

- Every window has their own window handle randomly generated by selenium
- We don't have to do any special for it.

- How do we get the current window's handle?
 - .getWindowHandle()

- What is the return type?
 - String
 - It will capture and return the current window handle as a string

- How do we get all of currently open windows' handles?
 - .getWindowhandles()

- What is the return type?
 - Set<String>

- Selenium wil only return the window handles from currently executed session.

 - Syntax: driver.switchTo().window(eachWindow);


-----------------------------------------------------------

- XPATH:

 - How do we go from parent to direct child?
  - "/" will take us to the direct child of given specific parent

  //tagname[@attribute='value']/directChildTag

 - How do we go from parent to any child?
  - "//" will take us to any child
  - It doesn't have to be direct child

 - How do we go from child to parent?
  -"/.."
  - We do not have to provide any tagname here. It will just take us to the parent

 - How do we go from sibling to sibling?
  - There are 2 methods for going from sibling to sibling
  - "/preceding-sibling::" will go to the sibling that comes before
  - "/following-sibling::" will go to the sibling that comes after

  - The web element we locate will become starting point(index 0)
  - We decide whether we want to go preceding or following sibling
  - We count and we pass the index number


  Ex: Locate option Orange 3 --> //option[@value='3']

  <select>
0        <option ></option>                    --> preceding element 2
1        <option ></option>                    --> preceding element 1
2       <option value="3"> Orange 3</option>   --> starting element 0
3       <option > </option>                    --> following element 1
4        <option ></option>                    --> following element 2
    </select>

--> Locate option 0 with using xpath: //option[@value='3']/preceding-sibling::option[2]

--> Locate option 3 with using xpath: //option[@value='3']/following-sibling::option[1]


- How do we use indexes with xpath?
 - //tagname[@attribute='value'][2]
 - If we use indexes without parantheses, this way will work only in direct sibling

 - (//tagname[@attribute='value'])[2]
 - If we use indexes with parantheses, this way will work and index through all web elements in html


--> Locate month May using its value

   (//option[@value='4'])[1]

--> Locate month March using May locator as a base and use sibling

   (//option[@value='4'])[1]/preceding-sibling::option[2]

--> Locate month October using May locator as a base and use sibling

   (//option[@value='4'])[1]/following-sibling::option[5]



--> P.I.Q:
 - How do you handle dynamic web elements?
 - How do you handle web elements with dynamic attribute value?

- Dynamic attribute value: it means some part of an attribute value is changing when the page is refreshed.

Solution #1. We can locate a parent/child that is not dynamic and move from there

Solution #2. We will use the methods provided by xpath: contains()
                                                        starts-with()
                                                        ends-with()


                                                cssSelector: contains --> *
                                                             starts-with --> ^
                                                             ends-with --> $




Before refresh the page --> 0ahUKEwj_krD97M76AhUmFVkFHe2aB1EQ39UDCAY

After refresh the page  --> 0ahUKEwi8hZHc6876AhUpF1kFHf5nBEUQ39UDCAY

xpath --> //tagname[starts-with(@attribute,'value')]

          //input[starts-with(@data-ved,'0ahUKEw')]

cssSelector --> tagname[attribute^='value']
                input[data-ved^='0ahUKEw']


xpath --> //tagname[ends-with(@attribute,'value')]

cssSelector --> tagname[attribute$='value']


xpath --> //tagname[contains(@attribute,'value')]
          //input[contains(@data-ved,'UDCAY')]

cssSelector --> tagname[attribute*='value']
                input[data-ved*='UDCAY']


                      come back at 4:08 EST



------------------------------------------------------------------

- WEBTABLES:

- HOW DO WE HANDLE WEBTABLES USING SELENIUM?
 - We write custom locators using xpath or cssSelector and get data we want to get

- How do we create HTML table?
 - <table> tag creates html table

#1. We create <table> tag
#2. We create <tr>
#3. We create cells which is <td>

tr: table row --> used to create rows inside table
th: table header --> used to create cells, but it will make content bolded and centered
td: table data --> used to create cells inside of rows in table



P1_ WRITE A LOCATOR THAT RETURNS THE TABLE 1 ITSELF

    //table[@id='table1']


P2_ WRITE A LOCATOR THAT RETURNS ALL OF THE ROWS INSIDE OF TABLE 1

    //table[@id='table1']//tr


P3_ WRITE A LOCATOR THAT RETURNS ALL OF THE ROWS INSIDE OF BODY - TABLE 1

    //table[@id='table1']/tbody//tr


P4_ WRITE A LOCATOR THAT RETURNS ONLY 3RD ROW IN THE BODY

    //table[@id='table1']/tbody//tr[3]


P5_ WRITE A LOCATOR THAT RETURNS ALL OF THE CELLS IN ALL OF THE ROW (IN BODY)

    //table[@id='table1']/tbody//tr//td


P6_ WRITE A LOCATOR THAT RETURNS ALL OF THE FIRST NAMES FROM TABLE

    //table[@id='table1']/tbody//tr//td[2]

    //td[2] --> get me the second cells from all rows


P7_ WRITE A LOCATOR THAT RETURNS FRANKS CELL SPECIFICALLY

    //table[@id='table1']/tbody//tr[2]//td[2]

    //tr[2] --> get me the second row from table in tbody
    //td[2] --> get me the second cells from second row


P8_ WRITE A LOCATOR THAT RETURNS FRANKS CELL SPECIFICALLY USE FRANKS TEXT

    //table[@id='table1']//td[.='Frank']


P9_ WRITE A LOCATOR THAT RETURNS $100 CELL SPECIFICALLY USE JASON TEXT

   //table[@id='table1']//td[.='Jason']/following-sibling::td[2]



P10_ WRITE A LOCATOR THAT RETURNS Tim's last name  BASED ON tim's NAME




P11_ WRITE A LOCATOR THAT RETURNS ALL EMAILS THAT HAS $50 DUE DATE